Next, there needs to be a centralized system that manages resources. This is important incase I want to make a game-state snapshot for storing or retrieving game files. For now we want a standalone class instance (singleton) that keeps track of resource collectors (in this case the player) and how many resource units it has per resource type. I want to make use of the IResourceCollector interface. The resource extraction should also get an interface IResourceExtraction which for now will just hold the type of resource and whether resource collection is allowed (True for now). In my mind the resource collector is responsible for signaling a request to the (global) resource manager if the proposed resource collection action (take N resources from resource extraction and put it in 'inventory' of resource collector). Only after the (global) resource manager agrees on the transaction, the action is allowed to take place. Once the progress time is completed, the resource manager counts the incoming resources. Note that, from the start of agreeing to the transaction, the resource manager needs to allocate an expected amount of resources obtained from once the transaction is completed. This is to prevent multiple transactions with different resource extractions to take place simultaneously, exceeding the total carrying capacity of the resource collector.

Similar to the previous comment, the OnExtractionExit here, does not properly release the allocated resources that got allocated when calling ResourceManager.Instance.RequestExtraction. Inside this function it is also difficult to know which resources where actually allocated and which are cancelled when calling this OnExtractionExit method. Could you help me design a more robust approach where, besides approving the extraction, the ResourceManager also passes an object which we can use to cancel the transaction order? This way the ResourceManager can keep track of which transaction orders it approves and for how much resources. Then either upon completing the transaction this object is called by CompleteTransaction() to tell the ResourceManager exactly which resources to remove from the allocated stack and which to add to the actual inventories.
Ontop of that, this transaction order object can call CancelTransaction() and the ResourceManager would know which allocated resources to release. Lets make a class for such a transaction order and a corresponding interface.